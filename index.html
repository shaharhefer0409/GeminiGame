<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Neon Nexus - Fullscreen</title>
    <style>
        /* CSS Mobile Fix: Ensures the container matches the physical screen size */
        body { 
            margin: 0; padding: 0; background-color: #000; 
            position: fixed; inset: 0; overflow: hidden; 
            font-family: 'Segoe UI', sans-serif; touch-action: none; color: white;
            height: 100vh; height: -webkit-fill-available;
        }
        #gameContainer { position: relative; width: 100%; height: 100%; }
        canvas { display: block; width: 100%; height: 100%; }
        
        .hud { position: absolute; z-index: 5; pointer-events: none; text-shadow: 0 2px 4px #000; font-weight: bold; }
        #scoreBoard { top: 20px; left: 20px; font-size: 24px; color: #0ff; }
        #hiScoreBoard { top: 20px; right: 20px; font-size: 18px; color: #f0f; opacity: 0.8; }
        
        #energyContainer { top: 60px; left: 20px; width: 150px; height: 12px; background: rgba(255,255,255,0.1); border-radius: 6px; overflow: hidden; border: 1px solid rgba(0, 255, 0, 0.3); }
        #energyFill { width: 0%; height: 100%; background: linear-gradient(90deg, #050, #0f0); box-shadow: 0 0 15px #0f0; transition: width 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275); }
        
        #ui-layer { position: absolute; inset: 0; display: flex; flex-direction: column; align-items: center; justify-content: center; background: rgba(0, 0, 0, 0.85); backdrop-filter: blur(10px); z-index: 10; text-align: center; }
        h1 { font-size: 10vw; color: #0ff; text-shadow: 0 0 25px #0ff; margin: 0; }
        button { padding: 18px 60px; font-size: 22px; background: none; color: #0ff; border: 2px solid #0ff; border-radius: 50px; cursor: pointer; transition: 0.3s; margin-top: 25px; font-weight: 900; text-transform: uppercase; outline: none; }
        button:active { transform: scale(0.95); background: #0ff; color: #000; }
        .hidden { display: none !important; }
    </style>
</head>
<body>

    <div id="gameContainer">
        <div id="scoreBoard" class="hud">Score: 0</div>
        <div id="hiScoreBoard" class="hud">Best: 0</div>
        <div id="energyContainer" class="hud"><div id="energyFill"></div></div>
        
        <canvas id="gameCanvas"></canvas>

        <div id="ui-layer">
            <h1 id="title">NEON NEXUS</h1>
            <p id="desc">ENERGY DECAYS OVER TIME.<br>Collect cells to activate Shield.</p>
            <button id="startBtn">ENGAGE</button>
        </div>
    </div>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const ui = document.getElementById('ui-layer');
    const scoreDisplay = document.getElementById('scoreBoard');
    const hiScoreDisplay = document.getElementById('hiScoreBoard');
    const energyFill = document.getElementById('energyFill');

    const AudioCtx = window.AudioContext || window.webkitAudioContext;
    let audioCtx;
    let musicLoop = null;

    let isGameOver = true;
    let score = 0;
    let energy = 0;
    const MAX_ENERGY = 8;
    let difficulty = 1;
    let lastTime = 0;
    let entities = [];
    let particles = [];
    let stars = [];
    let shake = 0;

    const player = { x: 0, y: 0, size: 42, dx: 0, speed: 850, tilt: 0, shield: false, shieldTime: 0 };

    hiScoreDisplay.innerText = "Best: " + (localStorage.getItem('neonNexusHi') || 0);

    // --- FULLSCREEN LOGIC ---
    

    function toggleFullscreen() {
        const elem = document.documentElement;
        if (!document.fullscreenElement) {
            if (elem.requestFullscreen) elem.requestFullscreen();
            else if (elem.webkitRequestFullscreen) elem.webkitRequestFullscreen();
            else if (elem.msRequestFullscreen) elem.msRequestFullscreen();
        }
    }

    // --- SOUND ENGINE ---
    function playSound(freq, type, duration, vol, rampUp = false) {
        if (!audioCtx) return;
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.type = type;
        osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
        if (rampUp) osc.frequency.exponentialRampToValueAtTime(freq * 2.5, audioCtx.currentTime + duration);
        else osc.frequency.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + duration);
        gain.gain.setValueAtTime(vol, audioCtx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + duration);
        osc.connect(gain); gain.connect(audioCtx.destination);
        osc.start(); osc.stop(audioCtx.currentTime + duration);
    }

    function stopMusic() { if (musicLoop) { clearInterval(musicLoop); musicLoop = null; } }

    function startBackgroundMusic() {
        stopMusic();
        let beat = 0;
        musicLoop = setInterval(() => {
            if (isGameOver) { stopMusic(); return; }
            if (audioCtx.state === 'suspended') audioCtx.resume();
            playSound(60, 'sine', 0.2, 0.45, false);
            if (beat % 2 === 0) {
                const scale = [110, 130, 146]; 
                const note = scale[Math.floor(Math.random() * scale.length)];
                playSound(note, 'triangle', 0.4, 0.18, false);
            }
            if (beat % 4 === 2) playSound(3500, 'sine', 0.05, 0.12, false);
            beat++;
        }, 250);
    }

    function resize() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        player.y = canvas.height - 130;
        player.x = canvas.width / 2;
    }
    window.addEventListener('resize', resize);
    resize();

    function handleInput(e) {
        if (isGameOver) return;
        const x = e.touches ? e.touches[0].clientX : e.clientX;
        player.dx = x < canvas.width / 2 ? -player.speed : player.speed;
        if (e.cancelable) e.preventDefault();
    }
    window.addEventListener('touchstart', handleInput, {passive: false});
    window.addEventListener('mousedown', handleInput);
    window.addEventListener('touchend', () => player.dx = 0);
    window.addEventListener('mouseup', () => player.dx = 0);

    class Star {
        constructor() { this.x = Math.random() * canvas.width; this.y = Math.random() * canvas.height; this.z = Math.random() * 0.5 + 0.1; }
        update(dt) { this.y += 200 * this.z * dt * (difficulty * 0.5); if (this.y > canvas.height) { this.y = -10; this.x = Math.random() * canvas.width; } }
        draw() { ctx.fillStyle = `rgba(150,200,255,${this.z})`; ctx.fillRect(this.x, this.y, 1.2, 1.2); }
    }

    class Particle {
        constructor(x, y, color) {
            this.x = x; this.y = y;
            this.vx = (Math.random() - 0.5) * 12; this.vy = (Math.random() - 0.5) * 12;
            this.life = 1.0; this.color = color;
        }
        update(dt) { this.x += this.vx; this.y += this.vy; this.life -= dt * 2.5; }
        draw() { ctx.fillStyle = this.color; ctx.globalAlpha = this.life; ctx.fillRect(this.x, this.y, 3, 3); ctx.globalAlpha = 1; }
    }

    class Entity {
        constructor() {
            this.type = Math.random() < 0.22 ? 'cell' : 'enemy';
            this.size = this.type === 'cell' ? 22 : 36;
            this.x = Math.random() * (canvas.width - this.size);
            this.y = -60;
            this.speed = (400 + Math.random() * 200) * (difficulty * 0.75);
            this.color = this.type === 'cell' ? '#0f0' : '#f0f';
            this.rot = 0;
        }
        update(dt) { this.y += this.speed * dt; this.rot += dt * 3; }
        draw() {
            ctx.save(); ctx.translate(this.x + this.size/2, this.y + this.size/2);
            ctx.rotate(this.rot); ctx.fillStyle = this.color;
            ctx.shadowBlur = 15; ctx.shadowColor = this.color;
            if (this.type === 'cell') { ctx.beginPath(); ctx.arc(0,0, this.size/2, 0, Math.PI*2); ctx.fill(); }
            else { ctx.fillRect(-this.size/2, -this.size/2, this.size, this.size); }
            ctx.restore(); ctx.shadowBlur = 0;
        }
    }

    function createExplosion(x, y, color) { for(let i=0; i<15; i++) particles.push(new Particle(x, y, color)); }

    function spawn() {
        if (isGameOver) return;
        entities.push(new Entity());
        setTimeout(spawn, Math.max(160, 800 / difficulty));
    }

    function update(timestamp) {
        if (isGameOver) return;
        if (!lastTime) lastTime = timestamp;
        let dt = Math.min((timestamp - lastTime) / 1000, 0.1);
        lastTime = timestamp;
        ctx.fillStyle = 'rgba(0,0,0,0.3)'; ctx.fillRect(0,0,canvas.width, canvas.height);
        ctx.save();
        if (shake > 0) { ctx.translate((Math.random()-0.5)*shake*20, (Math.random()-0.5)*shake*20); shake -= dt * 2; }
        stars.forEach(s => { s.update(dt); s.draw(); });
        for (let i = particles.length - 1; i >= 0; i--) {
            particles[i].update(dt); particles[i].draw();
            if (particles[i].life <= 0) particles.splice(i, 1);
        }
        if (!player.shield && energy > 0) {
            energy -= dt * 0.25; 
            energyFill.style.width = (energy / MAX_ENERGY) * 100 + '%';
        }
        player.x += player.dx * dt;
        player.x = Math.max(25, Math.min(canvas.width - 25, player.x));
        player.tilt += ((player.dx / player.speed) * 0.4 - player.tilt) * 0.15;
        ctx.save(); ctx.translate(player.x, player.y); ctx.rotate(player.tilt);
        ctx.fillStyle = player.shield ? '#0f0' : '#0ff'; ctx.shadowBlur = 20; ctx.shadowColor = ctx.fillStyle;
        ctx.beginPath(); ctx.moveTo(0, -28); ctx.lineTo(20, 22); ctx.lineTo(0, 12); ctx.lineTo(-20, 22); ctx.fill();
        ctx.restore();
        if (player.shield) {
            player.shieldTime -= dt;
            if (player.shieldTime <= 0) player.shield = false;
            ctx.strokeStyle = '#0f0'; ctx.lineWidth = 3; ctx.beginPath(); ctx.arc(player.x, player.y, 50, 0, Math.PI*2); ctx.stroke();
        }
        for (let i = entities.length - 1; i >= 0; i--) {
            const ent = entities[i];
            ent.update(dt); ent.draw();
            const dist = Math.hypot(player.x - (ent.x + ent.size/2), player.y - (ent.y + ent.size/2));
            if (dist < 45) {
                if (ent.type === 'cell') {
                    entities.splice(i, 1); energy = Math.min(energy + 2.2, MAX_ENERGY);
                    playSound(650, 'sine', 0.2, 0.45, true); createExplosion(ent.x, ent.y, '#0f0');
                    if (energy >= MAX_ENERGY) { player.shield = true; player.shieldTime = 4.5; energy = 0; playSound(1100, 'triangle', 0.4, 0.35, true); }
                } else if (!player.shield) { gameOver(); }
                else { entities.splice(i, 1); shake = 0.6; playSound(150, 'sawtooth', 0.1, 0.35, false); createExplosion(ent.x, ent.y, '#f0f'); }
            } else if (ent.y > canvas.height) { entities.splice(i, 1); score += 10; scoreDisplay.innerText = "Score: " + score; difficulty += 0.015; }
        }
        ctx.restore();
        requestAnimationFrame(update);
    }

    function gameOver() {
        isGameOver = true; shake = 1.8;
        stopMusic();
        playSound(70, 'sawtooth', 0.8, 0.65, false); 
        if (navigator.vibrate) navigator.vibrate([100, 50, 250]);
        const hiScore = localStorage.getItem('neonNexusHi') || 0;
        if (score > hiScore) localStorage.setItem('neonNexusHi', score);
        hiScoreDisplay.innerText = "Best: " + (localStorage.getItem('neonNexusHi') || score);
        document.getElementById('title').innerText = "CRASHED";
        ui.classList.remove('hidden');
    }

    function start() {
        toggleFullscreen(); // ACTIVATE FULLSCREEN ON START
        
        if (!audioCtx) audioCtx = new AudioCtx();
        if (audioCtx.state === 'suspended') audioCtx.resume();
        
        isGameOver = false; score = 0; energy = 0; difficulty = 1; shake = 0;
        entities = []; particles = []; lastTime = 0; player.shield = false;
        stars = Array(60).fill().map(() => new Star());
        scoreDisplay.innerText = "Score: 0";
        energyFill.style.width = '0%';
        ui.classList.add('hidden');
        startBackgroundMusic(); spawn();
        requestAnimationFrame(update);
    }

    document.getElementById('startBtn').onclick = start;
</script>
</body>
</html>
